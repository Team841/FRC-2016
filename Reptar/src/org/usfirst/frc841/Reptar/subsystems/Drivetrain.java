// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc841.Reptar.subsystems;

import java.sql.Driver;

import org.usfirst.frc841.Reptar.Robot;
import org.usfirst.frc841.Reptar.RobotMap;
import org.usfirst.frc841.Reptar.commands.*;
import org.usfirst.frc841.lib.PID.PIDControlLoop;
import org.usfirst.frc841.lib.PathPlanner.FalconPathPlanner;
import org.usfirst.frc841.lib.PathPlanner.PathFollower;

import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Notifier;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.networktables.NetworkTable;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * This Defines the Drivetrain subsystem.
 */
public class Drivetrain extends Subsystem {

	/*
	 * public double rightVelocity[] = { 0, 0.56, 1.12, 1.68, 2.24, 2.8, 3.36,
	 * 3.92, 4.48, 5.04, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26,
	 * 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26,
	 * 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26, 5.26 };
	 * 
	 * public double rightAcc[] = { 5.6, 5.6, 5.6, 5.6, 5.6, 5.6, 5.6, 5.6, 5.6,
	 * 5.6, 2.2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 * 0, 0, 0, 0, 0, 0, 0, 0 };
	 * 
	 * public double leftAcc[] = { 5.6, 5.6, 5.6, 5.6, 5.6, 5.6, 5.6, 5.6, 5.6,
	 * 5.6, 2.2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 * 0, 0, 0, 0, 0, 0, 0, 0 };
	 * 
	 * public double leftVelocity[] = { 0, 0.56, 1.12, 1.68, 2.24, 2.8, 3.36,
	 * 3.92, 4.48, 5.04, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39,
	 * 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39,
	 * 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39, 5.39 };
	 */

	public double leftVelocity[] = { 0, 0.7986707753, 1.597341551, 2.396012326, 3.194683101, 3.993353877, 4.792024652,
			5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1,
			5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1, 5.1 };
	public double leftAcc[] = { 7.986707753, 7.986707753, 7.986707753, 7.986707753, 7.986707753, 7.986707753,
			7.986707753, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController leftDrive1 = RobotMap.drivetrainLeftDrive1;
    private final SpeedController leftDrive2 = RobotMap.drivetrainLeftDrive2;
    private final SpeedController rightDrive2 = RobotMap.drivetrainRightDrive2;
    private final SpeedController rightDrive1 = RobotMap.drivetrainRightDrive1;
    private final Encoder leftQuad = RobotMap.drivetrainleftQuad;
    private final Encoder rightQuad = RobotMap.drivetrainrightQuad;
    private final Solenoid climbingSolenoid = RobotMap.drivetrainClimbingSolenoid;
    private final Solenoid shiftingSolenoid = RobotMap.drivetrainShiftingSolenoid;
    private final Compressor compressor1 = RobotMap.drivetrainCompressor1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Trajectory stuff
	double[][] waypoints = new double[][] {

			{ 7, 16 }, { 11, 16 }, { 17, 28 }, { 23, 29 }, };

	double totalTime = 12; // max seconds we want to drive the path

	double timeStep = 0.1; // period of control loop on Rio, seconds

	double robotTrackWidth = 2; // distance between left and right wheels,
								// feet

	FalconPathPlanner path = new FalconPathPlanner(waypoints);
	PathFollower automode;
	// Variables used for Cheesy Poofs Drive Style

	boolean isHighGear = false;
	private double oldWheel = 0.0;
	private double quickStopAccumulator = 0;
	private double throttleDeadband = 0.02;
	private double wheelDeadband = 0.02;
	private double sensitivityHigh = 0.85;
	private double sensitivityLow = 0.75;
	private boolean isQuickTurn = false;
	private boolean isStraight = false;
	private int counter1 = 0;

	// Network table variable for reading camera and Lidar
	NetworkTable table;
	boolean isCastlePresent = false;
	double castleCenter = 0;
	double distance = 0;

	// Control Loop Stuff Timer ControllerTimer;
	Notifier controlLoopTimer;

	private double period = .2; // Seconds
	public boolean isPathFollowEnable = false;
	public boolean isPathFinished = false;

	public double[][] accleft;
	public double[][] accright;
	public double[][] distleft;
	public double[][] distright;

	public class CLoop extends PIDControlLoop {
		// Create a object the same time of the subsystem used.
		Drivetrain test;

		// Take in the class and variables needed by the PID loop.
		public CLoop(Drivetrain test, double[] X, double[] Y, long sampleTime) {
			super(X, Y, sampleTime);
			this.test = test;
			// TODO Auto-generated constructor stub
		}

		// This is where we override the PID methodes with the Subsystem
		// Methodes
		@Override
		public void setOutput(double value) {

			test.SetLeftRight(value, value);
			// System.out.println("output: "+ value);

		}

		@Override
		public double getSensorReading() {
			return test.getCastleCenter();
		}

		@Override
		public void update() {
			SmartDashboard.putString("DB/String 1", "Castle Center: " + this.test.getCastleCenter());
		}

	}

	// PID Variable
	public Drivetrain.CLoop cloop;

	double x[] = { 1, 2, 3 };
	double y[] = { 0, 0, 0 };

	public Drivetrain() {
		this.initEncoder();
		// Calculate trajectory paths for Velocity, Acceleration, and distance
		// over time
		automode = new PathFollower(waypoints, totalTime, timeStep, robotTrackWidth);

		table = NetworkTable.getTable("SmartDashboard");
		path.calculate(totalTime, timeStep, robotTrackWidth);
		double[][] accleft = new double[path.smoothCenterVelocity.length][2];
		double[][] accright = new double[path.smoothCenterVelocity.length][2];
		double[][] distleft = new double[path.smoothCenterVelocity.length][2];
		double[][] distright = new double[path.smoothCenterVelocity.length][2];

		for (int i = 0; i < (path.smoothLeftVelocity.length - 2); i++) {
			accleft[i + 1][1] = (path.smoothLeftVelocity[i + 1][1] - path.smoothLeftVelocity[i][1]) / timeStep;
			accleft[i + 1][0] = path.smoothLeftVelocity[i][0];
			distleft[i + 1][1] = path.smoothLeftVelocity[i][1] * timeStep + distleft[i][1];
			distleft[i + 1][0] = path.smoothLeftVelocity[i][0];

			accright[i + 1][1] = (path.smoothRightVelocity[i + 1][1] - path.smoothRightVelocity[i][1]) / timeStep;
			accright[i + 1][0] = path.smoothRightVelocity[i][0];
			distright[i + 1][1] = path.smoothRightVelocity[i][1] * timeStep + distright[i][1];
			distright[i + 1][0] = path.smoothRightVelocity[i][0];

		}
		accleft[accleft.length - 1][1] = 0;
		accleft[accleft.length - 1][0] = accleft[accleft.length - 2][0] + timeStep;
		distleft[distleft.length - 1][1] = distleft[distleft.length - 2][1];
		distleft[accleft.length - 1][0] = accleft[accleft.length - 2][0] + timeStep;

		accright[accleft.length - 1][1] = 0;
		accright[accleft.length - 1][0] = accright[accright.length - 2][0] + timeStep;
		distright[distright.length - 1][1] = distright[distright.length - 2][1];
		distright[distright.length - 1][0] = accright[accright.length - 2][0] + timeStep;
		distright[accright.length - 1][0] = accright[accright.length - 2][0] + timeStep;

		controlLoopTimer = new Notifier(new loop(this, accleft, accright, distleft, distright));
		controlLoopTimer.startPeriodic(period);

		cloop = new Drivetrain.CLoop(this, x, y, (long) Math.abs(period * 100));
		cloop.setTunings(.0015, 0.002, .00023);
		cloop.SetOutputLimits(-1, 1);
		cloop.updateSetpoint(160);
		// cloop.enablePID = false;

	}

	class loop implements Runnable {
		private Drivetrain drivetrain;
		int counter = 0;
		// int cnt =0;
		public double[][] accleft;
		public double[][] accright;
		public double[][] distleft;
		public double[][] distright;
		public double[][] jerkleft;
		public double[][] jerkright;
		public double[][] snapleft;
		public double[][] snapright;
		double setpointL = 0;
		double errorL = 0;
		double error_derivL = 0;
		double error_lastL = 0;
		double setpointR = 0;
		double errorR = 0;
		double error_derivR = 0;
		double error_lastR = 0;

		// public loop(Drivetrain drivetrain, double[][] accleft, double[][]
		// accright,double[][] distleft, double[][] distright,
		// double[][] jerkleft, double[][] jerkright, double[][] snapleft,
		// double[][] snapright){
		public loop(Drivetrain drivetrain, double[][] accleft, double[][] accright, double[][] distleft,
				double[][] distright) {
			this.drivetrain = drivetrain;
			this.accleft = accleft;
			this.accright = accright;
			this.distleft = distleft;
			this.distright = distright;
			this.jerkleft = jerkleft;
			this.jerkright = jerkright;
			this.snapleft = snapleft;
			this.snapright = snapright;

		}

		@Override
		public void run() {
			// System.out.println(drivetrain.automode.path.smoothLeftVelocity[cnt][1]+
			// " " + drivetrain.path.smoothLeftVelocity[cnt][1]);
			// cnt++;

			if (drivetrain.isPathFollowEnable) {
				errorL = 0;
				errorR = 0;
				// errorL = distleft[counter][1] -
				// Math.abs(drivetrain.getLeftEncoderDistance());
				// errorR = distright[counter][1] -
				// Math.abs(drivetrain.getRightEncoderDistance());

				error_derivL = (errorL - error_lastL) / drivetrain.period;
				error_derivR = (errorR - error_lastR) / drivetrain.period;

				drivetrain.SetLeftRight(1/6.38*drivetrain.leftVelocity[counter], -1.05*1/6.38*drivetrain.leftVelocity[counter]);
				//drivetrain.SetLeftRight(
				//		0.86 * 1 / 5.4 * drivetrain.path.smoothLeftVelocity[counter][1]
				//				+ 1 / 3.5 * .55 * accleft[counter][1] + 2 / 3 * errorL,
				//		-0.9 * 1 / 5.3 * drivetrain.path.smoothRightVelocity[counter][1]
				//				- 1 / 3.5 * .6 * accright[counter][1] - 2 / 3 * errorR);
				drivetrain.postData();
				// implemented jerk and snap, need to figure out the attenuation
				/*
				 * drivetrain.SetLeftRight( 0.86 * 1/5.4 *
				 * drivetrain.path.smoothLeftVelocity[counter][1] + 1/3.5 * 0.55
				 * * accleft[counter][1] + 1/3.5 * 0.55 * jerkleft[counter][1] +
				 * 1/3.5 * 0.55 * snapleft[counter][1] + 2/3 * errorL, -0.9 *
				 * 1/5.3 * drivetrain.path.smoothRightVelocity[counter][1] -
				 * 1/3.5 * 0.6 * accright[counter][1] - 1/3.5 * 0.6 *
				 * jerkright[counter][1] - 1/3.5 * 0.6 * snapright[counter[1] -
				 * 2/3 * errorR);
				 */

				/*
				 * drivetrain.SetLeftRight(0.9*1/5.4 *
				 * drivetrain.leftVelocity[counter] + 1/3.5 * .8 *
				 * drivetrain.leftAcc[counter], 0.9*-1/5.3 *
				 * drivetrain.rightVelocity[counter] - 1/3.5 * .8 *
				 * drivetrain.rightAcc[counter]);
				 */

				// System.out.println(drivetrain.leftVelocity[counter]);

				counter++;
				error_lastL = errorL;
				error_lastR = errorR;
			}

			if (counter >= (drivetrain.path.smoothLeftVelocity.length - 1)) {
				drivetrain.isPathFinished = true;
				drivetrain.isPathFollowEnable = false;
				counter = 0;
			}

			// TODO Auto-generated method stub

		}

	}

	/**
	 * This method is here to assign the driver joystick to the style drive. You
	 * can choose between Cheesy style drive of Tank Drive.
	 * 
	 * @param stick
	 */
	public void Drive(Joystick stick) {
		// if (!this.EnablePID){
		cheesyDrive(stick);
		this.postData();
		// tankDrive(stick);
		// }
	}

	// Set the power on the left and right motor drive
	public void SetLeftRight(double LPower, double RPower) {
		// this.PIDOutput = LPower;
		leftDrive1.set(LPower);
		leftDrive2.set(LPower);
		rightDrive1.set(RPower);
		rightDrive2.set(RPower);
	}

	/**
	 * Shift drive to high gear and update memory
	 */
	public void SetHighGear() {
		shiftingSolenoid.set(false);
		climbingSolenoid.set(false);
		isHighGear = true;
	}

	/**
	 * Shift drive train to low gear and update memory
	 */
	public void SetLowGear() {
		shiftingSolenoid.set(true);
		climbingSolenoid.set(false);
		isHighGear = false;

	}

	/**
	 * Engages the gearbox to power the winch and disables drive capability.
	 */
	public void climbingEnabled() {
		climbingSolenoid.set(true);
		shiftingSolenoid.set(false);
	}

	/**
	 * This method takes in object joystick and returns the yaxis value of the
	 * left most side of the gamepad.
	 * 
	 * @param stick
	 * @return yAxis
	 */
	public double getThrottle(Joystick stick) {
		return stick.getY();
	}

	/**
	 * This method takes in the object joystick and returns the x axis value to
	 * the right most side of the gamepad.
	 * 
	 * @param stick
	 * @return xAxis
	 */
	public double getWheel(Joystick stick) {
		return stick.getZ();
	}

	/**
	 * This method takes in the object joystick and returns the y axis value to
	 * the left most side of the gamepad.
	 * 
	 * @param stick
	 * @return yAxis
	 */
	public double getYAxisLeftSide(Joystick stick) {
		return stick.getY();
	}

	/**
	 * This method takes inthe ojbect joystick and returns the y axis value to
	 * the right most siide of the gamepad.
	 * 
	 * @param stick
	 * @return
	 */
	public double getYAxisRightSide(Joystick stick) {
		return stick.getThrottle();
	}

	/**
	 * This method takes in the driver controller and allows for tank style
	 * drive of the robot. A smoothness function is done to allow for a smoother
	 * control.
	 * 
	 * @param stick
	 */
	public void tankDrive(Joystick stick) {
		double axisNonLinearity;
		// Get Y axis and make a deadband
		double leftY = handleDeadband(getYAxisLeftSide(stick), 0.02);
		double rightY = handleDeadband(getYAxisRightSide(stick), 0.02);

		if (isHighGear) {
			axisNonLinearity = 0.5;
			// Smooth the controls on Left side
			leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);
			leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);

			// Smooth the controls on Right side
			rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);
			rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);
		} else {
			axisNonLinearity = 0.5;
			// Smooth the controls on Left side
			leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);
			leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);

			// Smooth the controls on Right side
			rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);
			rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) / Math.sin(Math.PI / 2.0 * axisNonLinearity);
		}

		// set the motors
		SetLeftRight(leftY, rightY);

	}

	/**
	 * Enable quick turn AKA classical Arcade drive
	 */
	public void setQuickTurn() {
		isQuickTurn = true;
	}

	/**
	 * Disable quick turn
	 */
	public void resetQuickTurn() {
		isQuickTurn = false;
	}

	/**
	 * This method does the Halo drive and is the slim down version of the
	 * cheesy poofs drive style. It has the capability to auto shift if
	 * uncommented.
	 * 
	 * @param stick
	 */
	public void cheesyDrive(Joystick stick) {

		// Note quickturn and shift is taken care of with buttons in OI.

		double wheelNonLinearity;
		double wheel = handleDeadband(getWheel(stick), wheelDeadband); // double
																		// wheel
																		// =
																		// handleDeadband(controlBoard.rightStick.getX(),
																		// wheelDeadband);
		double throttle = -handleDeadband(getThrottle(stick), throttleDeadband);
		double negInertia = wheel - oldWheel;
		/*
		 * if(getAverageSpeed()> 2000){ SetHighGear(); } else if
		 * (getAverageSpeed() < 1500){ SetLowGear(); }
		 */

		oldWheel = wheel;
		if (isHighGear) {
			wheelNonLinearity = 0.6;
			// Apply a sin function that's scaled to make it feel better.
			wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) / Math.sin(Math.PI / 2.0 * wheelNonLinearity);
			wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) / Math.sin(Math.PI / 2.0 * wheelNonLinearity);
		} else {
			wheelNonLinearity = 0.5;
			// Apply a sin function that's scaled to make it feel better.
			wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) / Math.sin(Math.PI / 2.0 * wheelNonLinearity);
			wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) / Math.sin(Math.PI / 2.0 * wheelNonLinearity);
			wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) / Math.sin(Math.PI / 2.0 * wheelNonLinearity);
		}

		double leftPwm, rightPwm, overPower;
		double sensitivity = 1.7;
		double angularPower;
		double linearPower;
		// Negative inertia!
		double negInertiaAccumulator = 0.0;
		double negInertiaScalar;

		if (isHighGear) {
			negInertiaScalar = 5.0;
			sensitivity = sensitivityHigh; // sensitivity =
											// Constants.sensitivityHigh.getDouble();
		} else {
			if (wheel * negInertia > 0) {
				negInertiaScalar = 2.5;
			} else {
				if (Math.abs(wheel) > 0.65) {
					negInertiaScalar = 5.0;
				} else {
					negInertiaScalar = 3.0;
				}
			}
			sensitivity = sensitivityLow; // sensitivity =
											// Constants.sensitivityLow.getDouble();
			if (Math.abs(throttle) > 0.1) {
				// sensitivity = 1.0 - (1.0 - sensitivity) / Math.abs(throttle);
			}
		}

		double negInertiaPower = negInertia * negInertiaScalar;
		negInertiaAccumulator += negInertiaPower;
		wheel = wheel + negInertiaAccumulator;
		if (negInertiaAccumulator > 1) {
			negInertiaAccumulator -= 1;
		} else if (negInertiaAccumulator < -1) {
			negInertiaAccumulator += 1;
		} else {
			negInertiaAccumulator = 0;
		}
		linearPower = throttle;
		// Quickturn!
		if (isQuickTurn) {
			if (Math.abs(linearPower) < 0.2) {
				double alpha = 0.1;
				quickStopAccumulator = (1 - alpha) * quickStopAccumulator + alpha * limit(wheel, 1.0) * 5;
			}
			overPower = 1.0;
			if (isHighGear) {
				sensitivity = 1.0;
			} else {
				sensitivity = 0.10;

			}
			angularPower = wheel;
		} else {
			overPower = 0.0;
			angularPower = Math.abs(throttle) * wheel * sensitivity - quickStopAccumulator;
			if (quickStopAccumulator > 1) {
				quickStopAccumulator -= 1;
			} else if (quickStopAccumulator < -1) {
				quickStopAccumulator += 1;
			} else {
				quickStopAccumulator = 0.0;
			}
		}
		rightPwm = leftPwm = linearPower;
		leftPwm += angularPower;
		rightPwm -= angularPower;
		if (leftPwm > 1.0) {
			rightPwm -= overPower * (leftPwm - 1.0);
			leftPwm = 1.0;
		} else if (rightPwm > 1.0) {
			leftPwm -= overPower * (rightPwm - 1.0);
			rightPwm = 1.0;
		} else if (leftPwm < -1.0) {
			rightPwm += overPower * (-1.0 - leftPwm);
			leftPwm = -1.0;
		} else if (rightPwm < -1.0) {
			leftPwm += overPower * (-1.0 - rightPwm);
			rightPwm = -1.0;
		}
		SetLeftRight(leftPwm, -rightPwm);

	}

	/**
	 * If the value is too small make it zero
	 * 
	 * @param val
	 * @param deadband
	 * @return value with deadband
	 */
	public double handleDeadband(double val, double deadband) {
		return (Math.abs(val) > Math.abs(deadband)) ? val : 0.0;
	}

	/**
	 * If the value is too large limit it.
	 * 
	 * @param v
	 * @param limit
	 * @return value with a max limit
	 */
	public static double limit(double v, double limit) {
		return (Math.abs(v) < limit) ? v : limit * (v < 0 ? -1 : 1);
	}

	/**
	 * Initialize the compressor for self regulation of the pneumatics.
	 */
	public void InitCompressor() {
		this.compressor1.enabled();
	}

	// Settings for Quadrature Encoders;
	private double MaxPeriod = 0.1;
	private double MinRate = 10;
	private int AverageSamples = 7;
	private double wheelDiameter = 6;
	private double DistancePerPulse = (Math.PI * wheelDiameter) / 255 / 12;

	/**
	 * Initialize the Quadrature encoder sensors for measurements.
	 */
	public void initEncoder() {
		// Set Direction
		leftQuad.setReverseDirection(true);
		rightQuad.setReverseDirection(false);

		// Set rate
		leftQuad.setDistancePerPulse(DistancePerPulse);
		rightQuad.setDistancePerPulse(DistancePerPulse);

		// Reset Quad;
		leftQuad.reset();
		rightQuad.reset();

	}

	/**
	 * This method returns the distance in feet from the left quadrature
	 * measurement.
	 * 
	 * @return leftside Distance in feet
	 */
	public double getLeftEncoderDistance() {
		return leftQuad.get() / 255.00 * wheelDiameter * Math.PI / 12;
	}

	/**
	 * This method returns the distance in feet from the right quadrature
	 * measurement.
	 * 
	 * @return rightside Distance in feet
	 */
	public double getRightEncoderDistance() {
		return rightQuad.get() / 255.00 * wheelDiameter * Math.PI / 12;
	}

	/**
	 * This method resets the encoders
	 */
	public void resetEncoders() {
		// Reset Quad;
		leftQuad.reset();
		rightQuad.reset();
	}

	/**
	 * This method takes in the left and right speeds and averages out to give a
	 * total forward moving speed.
	 * 
	 * @return average speed of robot
	 */
	public double getAverageSpeed() {
		double left = 0;
		double right = 0;
		double average = 0;
		left = leftQuad.getRate();
		right = rightQuad.getRate();

		average = Math.abs((right + left) / 2);
		return average;
	}

	/**
	 * This method gets the velocity of the left side wheel
	 * 
	 * @return leftSpeed
	 */
	public double getLeftSpeed() {
		return leftQuad.getRate();
	}

	/**
	 * This method gets the velocity of the right side wheel
	 * 
	 * @return
	 */
	public double getRightSpeed() {
		return rightQuad.getRate();
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		setDefaultCommand(new Drive());
	}

	/**
	 * This method reads the network table variable to see if the castle goal is
	 * present or not.
	 * 
	 * @return true if castle is present
	 */
	public boolean isCastlePresent() {
		if (table.getNumber("BLOB_COUNT", 0.0) != 0) {
			isCastlePresent = true;
		} else {
			isCastlePresent = false;
		}
		return isCastlePresent;
	}

	/**
	 * This method takes in the the two x limits of the castle goal from the
	 * network table and gives the middle
	 * 
	 * @return center position of castle
	 */
	public double getCastleCenter() {
		castleCenter = (table.getNumber("X1", 0.0) + table.getNumber("X2", 0.0)) / 2;
		return castleCenter;
	}

	/**
	 * This method provides the distance between the robot and the castle from
	 * the network table.
	 * 
	 * @return Robot distance from castle
	 */
	public double getDistance() {
		distance = table.getNumber("DEPTH", 0.0);
		return distance;
	}

	public void postData() {
		System.out.println(this.getLeftSpeed() + "," + this.getRightSpeed() + "," + this.getLeftEncoderDistance() + ","
				+ this.getRightEncoderDistance() + "," + Timer.getFPGATimestamp());
	}

}
